# CSS의 기본을 되돌아 보다.

CSS의 기본을 되돌아 CSS 디자인을 생각하기에 CSS의 기본 인 선택기 및 상세도를 이해하고 있어야합니다. CSS는 파탄 해가는 요인의 하나는 선택이 복잡하게되어 버려, 관리 다 할 수 없게되어 버리는 것입니다. 제 3 장 구성 요소 설계를 생각하는데 있어서도 중요한 포인트가되기 때문에, 여기에서 복습 해 둡시다.

## CSS선택자 및 상세도

CSS설계의 언어에 깊이 들어가기 전에, css케스케이딩, 선택자 사양을 되돌아 봅시다.

### 케스케이딩 기본

CSS는 케스케이딩 스타일 시트의 약자로 케스케이드(폭포)와 같이 먼저 선언된 규칙세트가 그 조건등에 따라 나중에 선언된 규첵 세트에 의해 상속 또는 덮어 쓰기가 됩니다.

    **CSS**
    .primary {
        color: red;
    }

    .primary {
        color: green; /* 이 쪽의 규칙이 적용 됨 */
    }

예를 들어 다음과 같은 규칙 집합이있을 경우 이후에 설명되어있는 save 규칙 쪽이 적용됩니다. CSS에서의 기술상 만약 button과 .save를 교체하면 역시 button 쪽이 적용됩니다.

    **HTML**
    <button class="button save">저장하기</button>

    **CSS**
    .button {
        display: inline-block;
        border: 1px solid #000;
        padding: .4em 1em;
        background-color: #eee;
        font-size: 1em;
        color: #000;
    }
    .save {
        border-color: green; /* 보더 색을 덮는다. */
        background-color: lightgreen; /* 배경색을 덮는다. */
        color: green; /* 글자 색값을 덮는다. */
    }

다만 이들은 같은 특이성입니다, 라는 조건이 충족되어 있다고 가정합니다.

### 특이성

CSS 선택기 어떤 요소에 스타일을 적용시킬 것인지를 지정합니다. 다음 코드는 success 값을 class 속성에있는 요소의 글자 색을 green하는 규칙 세트입니다.

    **CSS**
    .success {
        color: green;
    }

선택기는 상세도 (Specificity)라는 조건이 있습니다. 선택기의 내용이보다 구체적으로 상세할수록 그 규칙 세트가 우선됩니다 자세한 순위는 다음 순서로 높아집니다.

상세도가 높다
- !important
- 인라인 스크립트( style 속성)
- id 선택자
- 클래스선택자. 특성선택자. 의사클래스
- 요소선택자. 의사클래스
- 유니버셜 선택자
상세도가 낮다.

1. !important

!important는 비장의 카드인 선언입니다. 속성값 뒤에 공백 뒤에 선언하는 것으로 가장 우선되는 규칙입니다.

    **css**
    .primary {
        color: green !important;
    }

!important는 기본적으로 피하고 싶은 기술입니다. 만약 이것이 많이 사용되고 있는 상태가 되어 있는 것은 기존 css가 높은 디테일 선언으로 가득차서 어쩔 수 없는 상태에 있을때 입니다. 이것이야 말로 css의 큰 파탄이 시작되는 조짐이라고 할 수 있습니다. 그러나 !important를 능동적으로 의도적으로 사용하는 것은 허용 될 수 있습니다. 이에 대해서는 제 3장에서 설명합니다.

2. inline기술

inline기술이라는 것은, HTML의 style속성에 따른 스타일 기술입니다.

    **HTML**

    <button style="color: green;">버튼</button>

CSS 파일 또는 HTML에서의 style 요소 등에 기술 된 규칙보다 우선합니다. 상황에 따라 다르지만 기본적으로는이 기술 방법도 피하는 것이 좋습니다. 상세도의 이야기를 놓았다 해도 스타일은 외부 파일화 된 CSS 파일에서 일원 관리하는 것이 관리 상 바람직하다고 할 것이므로, 그러한 이유로 추천하지 않습니다 이렇게 직접 style 속성으로 스타일을 설명하는 경우 로 디버깅을 위해 일시적으로 스타일을 갖게 싶다 든가, 정말 그 곳에서나 쓰이는 위해 CSS 파일에 설명하고 싶지 않아 같은 것은있을 수 없습니다. 또한 JavaScript 의해 style 속성에 직접 스타일을 쓰는 경우도 있습니다 예를 들어, jQuery 플러그인이 강제로 설정하는 임의의 스타일과 표시 상태를위한 display : none 작업 등입니다. 있다면 이렇게 한 JavaScript의 조작에 의한 스타일 변경도 스타일 규칙 자체는 CSS 파일에서 가지고 javascript에서는 클래스를 붙이거나 분리할 만 할 것 같은 방법을 취하는 것이 바람직하다고 생각합니다. 이쪽도 자세한 내용은 제 3장 smacss에서 설명합니다.

3. ID선택자

ID는 도큐멘트(페이지)안에서 한번만 사용이 가능 합니다.
HTML에서id="foo"라고 붙인 요소가 있다고 한다면 그 foo라는 id는 동일한 도큐멘트에서는 한번밖에 이용할 수 없습니다. 그런 특유의 식별자는 CSS선택자로서는 가장 높은 상세도 입니다.

    **CSS**
    #primary {
        color: red; // 이쪽의 규칙이 적용된다.
    }

    .primary {
        color: green;
    }

    button {
        color: blue;
    }

4. 클래스 선택자, 속성선택자, 의사 클래스

ID보다 상세도는 낮고, 다음 소개하는 요소선택자보다 높은 것이 이러한 선택자 입니다. 이 크드는 클래스선택자의 예입니다.

    **CSS**
    .primary {
        color: green; // 이 쪽의 규칙이 적용 된다.
    }

    button {
        color: blue;
    }

ID와는 달리, class속성은 도큐멘트 안에서 몇번을 사용해도 상관 없습니다.
또 class속성과 동일한 수준에서 속성 선택자 의사 클래스 선택자의 상세도가 모여 있습니다. 속성 선택자는 요소가 가지는 속성의 유무 또는 속성값과 조건에 부합되는지 여부를 선택할 수 있습니다.

    **HTML**

    <div>
        <button class="primary">버튼</button>
        <button class="secondary">버튼</button>
    </div>

    **CSS**

    [class="primary"] { // class속성에 primary만 들어있는 요소를 선택
        color: green; // 이 규칙이 적용됩니다.
    }

    button {
        color: blue;
    }

의사 클래스는 의사 클래스라는 이름 그대로 조건에 일치되는 요소의 클래스 선택자자 수준으로 규칙이 적용됩니다.

    **CSS**
    button:first-child { // 첫번째 자식요소 선택
        color: green; // 이 규칙이 적용 됩니다.
    }

    button {
        color: blue;
    }

5. 요소선택자, 의사 요소

요소를 직접 선택하는 선택자는 ID나 클래스보다도 상세도는 낮습니다.
또  ::before, ::after 라는 의사 요소도 동일 합니다.

6. 유니버셜 선택자

\*을 사용한 선택자는 모든 요소에 일치하는 선택자 입니다. 유니버셜 선택자는 상세도를 가지지 않고, 어떤 선택자보다도 약한 선택자 입니다.
모든 요쇼를 대상으로 하는 장점이 있기때문에 프로젝트의 초기 스타일을 리셋하는 목적으로 사용되는 것도 있습니다만 퍼포먼스(속도)의 관점이나 리셋이 되지 않아도 되는 요소도 대상이 되어버리고 마는등의 이유로 최근에는 그 목적에 사용하는 것은 별로 권장되지 않습니다.

    **CSS**
    * { // 모든 요쇼의 margin, padding을 0으로 한다.
        margin: 0;
        padding: 0;
    }

## 상세도의 순위 계산

각 선택자의 우선순위는 앞에 서술했지만 실제로는 이러한 조합되어 있는 것에 의한 것보다 복잡합니다.예에서는 1개의 클래스 선택자와 2개의 클래스 선택자의 규첫세트가 있을 경우에는 후자의 쪽이 우선 됩니다.

    **CSS**
    .widget .title {
        font-size: 16px; // 이 규직이 적용된다.
    } 

    .title {
        font-size: 18px;
    }

상세도의 순위 계산은 조금 복잡합니다만 다음의 소개하는 도구를 이용하면서 이해를 쌓는 것이 좋겠습니다.

단순히 각 선택자가 가지는 상세도를 수치화해서 그것들을 합산하는 것 만이 아니고, 각각의 단위로서 상세도를 누적하여 높은편이 우선됩니다. 요소선택자는 얼마나 많은 수가 있어도 1개의 클래스 선택자보다 더 우선되지 않습니다. 클래서선택자는 얼마나 많은 수가 있어도 1개의 ID선택자보다 우선되지 않습니다. 마찬가지로 수에 관계없이 인라인 이나 !important가 사용되었을 경우는 그것들이 최우선 됩니다.

    **CSS**
    #main .section .title spoan {...} // id=1, class=2, 요소=1
    #main .title span.date {...} // id=1, class=2, 요소=1
    .single #main .title span.date {...} // id=1, class=3, 요소=1 (이것이 최우선 됩니다.)

    힌트1.

    일부 오래된 브라우서에서는 클래스 선택자가 256을 초과하면 ID선택자보다 우선되는 버가가 있습니다만, 현식적으로 그정도 수의 선택자가 될 수 없으므로 걱정하지 않아도 됩니다.

[이전 페이지](https://github.com/fireworks80/css-japan-book-translate/blob/master/1-2.md)
[다음 페이지](https://github.com/fireworks80/css-japan-book-translate/blob/master/2-2.md)